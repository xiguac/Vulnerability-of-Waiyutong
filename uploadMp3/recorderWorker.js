var sampleRate, channelNumber, sampleBits,
panel = 10,		//片数  修改片数时，相应修改send时  Module.TOTAL_MEMORY 否则会溢出
transBuffer = [],
wavArray = {},
TinSoConfig = null,
apiVersion = '1.0.1',
worker = self;

function PCMObject(testId, type, content, time, recordTime){
	// 任务id
	this.id = null;
	// 试题id
	this.testId = testId;
	// 类型
	this.type = type;
	// 内容
	this.content = content;
	// 时间戳
	this.time = time;
	// 录音时长
	this.recordTime = recordTime;
	// 传输位置
	this.position = 0;
	// 分片时待上传数组
	this.wait = [];
	// 上传完的mp2文件名
	this.uploaded = [];
	// 创建任务次数
	this.taskTimes = 0;
	// 上传次数
	this.uploadTimes = 0;
	// 识别次数
	this.recognizeTimes = 0;
	// 识别等待次数
	this.recognizeWaitTimes = 0;
	// 录音是否结束
	this.recording = true;
	// 是否接受到响应
	this.received = false;
	// 左声道数据
	this.bufferL = [];
	// 右声道数据
	this.bufferR = [];
	// 单声道字节数
	this.recLength = 0;
	// wav格式，用于播放
	this.blob = null;
	// mp2格式
	this.mp2 = null;
	// 是否在转换
	this.convert = false;
	// 识别结果
	this.result = null;
	// 是否分片上传mp2
	this.partMp2 = false;
	// 当前的定时任务函数
	this.currentCall = null;
	// 当前片数
	this.currentPanel = 0;

//	console.log("PCMObject.construct");
	var that = this;
	// 删除已上传录音
	this.shift = function(){
		this.wait.shift();
	}
	// 开始录音
	this.start = function(){
//		console.log("PCMObject.start");
		if(this.taskTimes > 10){
			clearInterval(that.handle);
			that.handle = null;
			var resultHandle = setInterval(function(){
				if(that.recording){
					return;
				}
				clearInterval(resultHandle);
				that.setResult({count : '0'}, that.time);
			}, 100);
			return;
		}
		var tapeTimeHandle = setInterval(function(){
			if(!that.recording){
				clearInterval(tapeTimeHandle);
			}
			that.setTapeTime();
		}, 200);
		this.taskTimes++;
		this.currentCall = this.start;
		var json = { apiVersion : apiVersion, type : this.type, content : this.content };

		var start = (new Date()).getTime();
		ajax(TinSoConfig.asr + '/Mp3/newAsr.html', JSON.stringify(json), function(data){
			// 负载均衡502异常时，data的值是空字符串，需要特别处理，否则JSON.parse('')会报错，并不再执行后续代码
			try{
				var msg = JSON.parse(data);
				// 成功则设置id，并将下一次的回调函数设为发送
				if(msg.status == '1'){
					that.setId(msg.id);
					that.currentCall = that.send;
					var time = (new Date()).getTime() - start;
					if(time > 1000){
						console.log(msg.id + '识别任务创建成功，用时：' + time + '毫秒，网络较差。');
					}else{
						console.log(msg.id + '识别任务创建成功，用时：' + time + '毫秒');
					}
				}else{
					console.log('创建识别任务失败，' + msg.content);
				}
			}catch (e) {
				console.log('服务器出现错误，接收到的参数为' + data);
			}
//			console.log(data);
			that.received = true;
		});
	}
	// 结束录音
	this.stop = function(){
//		console.log("PCMObject.stop");
		that.recording = false;
		that.lastTime = (new Date()).getTime();
	}
	// 设置id
	this.setId = function(id){
//		console.log("PCMObject.setId");
		this.id = id;
	}
	// 发送录音数据
	this.send = function() {
		// 如果id还没返回，则继续等待
		if(!that.id){
			return;
		}
		that.currentCall = that.send;
		var buffer = null;
		// mp2分片传输
		if(this.partMp2){
			// 如果没有要上传的数据，则返回
			if(that.wait.length == 0){
				// 如果已经结束录音，则发送判分消息，并关闭定时器
				if(!that.recording){
					console.log(that.id + '音频上传完成');
					that.currentCall = that.end;
					that.received = true;
					return null;
				}
				that.received = true;
				return null;
			}
			if(that.wait[0].indexPanel != panel ){
				if(that.recording){
					that.received = true;
					return null;
				}
			}
			// 如果已经转换过，则不再转换
			if(!that.wait[0].mp2){
				// 尚未转换，则转换，并等待返回
				if(!that.wait[0].convert){
					self.postMessage({command : 'convert', wav : that.wait[0].buffer, id : that.id});
					that.wait[0].convert = true;
				}
				that.received = true;
				return;
			}
			
			// 上传5次以上，则不再上传当前片段
			if(that.wait[0].uploadTimes > 5){
				that.shift();
				that.received = true;
				return null;
			}
			buffer = that.wait[0].mp2
			that.wait[0].uploadTimes++;
		}
		// 整体上传
		else{
			// 录音尚未结束，则继续等待
			if(that.recording){
				that.received = true;
				return;
			}
			// 没有转成mp2，则获取mp2
			if(!that.mp2){
				if(!that.convert){
					that.getWave();
					that.convert = true;
				}
				that.received = true;
				return;
			}
			buffer = that.mp2;
			// 上传5次以上，则不再上传，进行识别处理
			if(that.uploadTimes > 5){
				that.currentCall = that.end;
				that.received = true;
				return;
			}
			that.uploadTimes++;
		}

		var extra = {};
		extra.apiVersion = apiVersion;
		extra.id = that.id;
		extra.index = that.uploaded.length + 1;
		ajax(TinSoConfig.asr + '/Mp3/uploadMp3.html', buffer, function(data){
			// 负载均衡502异常时，data的值是空字符串，需要特别处理，否则JSON.parse('')会报错，并不再执行后续代码
			try{
				var msg = JSON.parse(data);
				// 成功则将文件名添加入已上传数组中，为最后识别做准备
				if(msg.status == '1'){
					that.uploaded.push(msg.name);
					// mp2分片传输则删除已传的音频
					if(this.partMp2){
						that.shift();
					}
					// 不分片则进行识别处理
					else{
						var time = (new Date()).getTime();
						console.log(that.id + '音频上传完成' + ', 转码+上传用时：' + (time - that.lastTime) + '毫秒');
						that.currentCall = that.end;
					}
				}else{
					// 如果服务器出现一些无法继续处理的错误，则停止上传减少本地压力
					if(msg.end == '1'){
						clearInterval(that.handle);
						that.handle = null;
						var resultHandle = setInterval(function(){
							if(that.recording){
								return;
							}
							clearInterval(resultHandle);
							that.setResult({count : '0'}, that.time);
						}, 100);
					}
					console.log(that.id + '上传mp2失败，' + msg.content);
				}
			}catch (e) {
				console.log('服务器出现错误，接收到的参数为' + data);
			}
//			console.log(data);
			that.received = true;
		}, JSON.stringify(extra));
	}
	// 设置下一次追加位置
	this.setPosition = function(position){
//		console.log("PCMObject.setPosition");
		this.position = position;
	};
	// 结束识别，开始判分
	this.end = function(){
//		console.log("PCMObject.end");
		this.currentCall = this.end;
		if(this.recognizeTimes > 100){
			clearInterval(that.handle);
			that.handle = null;
			var resultHandle = setInterval(function(){
				if(that.recording){
					return;
				}
				clearInterval(resultHandle);
				that.setResult({count : '0'}, that.time);
			}, 100);
			return;
		}
		// 第一次识别时等待50毫秒，以后每次等500毫秒
		if(this.recognizeTimes > 0 && this.recognizeWaitTimes < 10){
			this.recognizeWaitTimes++;
			that.received = true;
			return;
		}
		this.recognizeWaitTimes = 0;
		this.recognizeTimes++;
		var json = { apiVersion : apiVersion, id : this.id, audio : this.uploaded, type : 'mp2'};
		ajax(TinSoConfig.asr + '/Mp3/recognize.html', JSON.stringify(json), function(data){
			// 负载均衡502异常时，data的值是空字符串，需要特别处理，否则JSON.parse('')会报错，并不再执行后续代码
			try{
				var msg = JSON.parse(data);
				// 识别成功则设置结果
				if(msg.status == '1'){
					that.setResult(msg.result, msg.mp3);
					var time = (new Date()).getTime();
					console.log(that.id + '识别已经结束' + ', 转码+识别用时：' + (time - that.lastTime) + '毫秒');
				}
				else if(msg.status == '2'){
//					console.log(that.id + msg.content);
				}
				else{
					console.log(that.id + '识别失败，' + msg.content);
				}
			}catch (e) {
				console.log('服务器出现错误，接收到的参数为' + data);
			}
//			console.log(data);
			that.received = true;
		});
	};
	// 设置结果
	this.setResult = function(result, mp3){
//		console.log("PCMObject.setResult");
		clearInterval(this.handle);
		this.result = result;
		self.postMessage({command : 'setResult', time : this.time, result : this.result, mp3 : mp3, testId : this.testId});
	}
	// 设置已录音时间
	this.setTapeTime = function(){
		self.postMessage({command : 'setTapeTime', tid : this.testId, time : this.time, tapeTime : this.recLength * 1000 / sampleRate, recordTime : this.recordTime});
	}
	this.length = function(){
		return this.wait.length;
	};
	// 添加新的pcm数据
	this.record = function(inputBufferL, inputBufferR) {
		if(!!this.handle){
			this.bufferL.push(inputBufferL);
			this.bufferR.push(inputBufferR);
			var dataLength = inputBufferL.length;
			if(channelNumber == 2){
				dataLength += inputBufferR.length;
			}
			this.recLength += dataLength;
//			if(this.recLength / sampleRate >= (this.recordTime / 1000)){
//				self.postMessage({command : 'stop'});
//				return;
//			}
			// mp2分片传输
			if(this.partMp2){
				dataLength = dataLength * (sampleBits / 8);
				
				if(this.wait.length == 0 || this.wait[this.wait.length - 1].indexPanel == panel){
					this.wait.push({indexPanel : 0, buffer : new ArrayBuffer(dataLength * panel), mp2 : null, uploadTimes : 0, convert : false});
				}
				var buffer = this.wait[this.wait.length - 1].buffer;
				var dataview = new DataView(buffer);

				var offset = dataLength * this.wait[this.wait.length - 1].indexPanel;
				// 左声道
				for(var j = 0; j < inputBufferL.length; j++){
					var s = Math.max(-1, Math.min(1, inputBufferL[j]));
					dataview.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
					offset += 2;
				}
				// 右声道
				if(channelNumber == 2){
					for(var j = 0; j < inputBufferR.length; j++){
						var s = Math.max(-1, Math.min(1, inputBufferR[j]));
						dataview.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
						offset += 2;
					}
				}
				this.wait[this.wait.length - 1].indexPanel += 1;
			}
		}
	};
	this.getWave = function(){
		if(!this.blob){
			var time = (new Date()).getTime();
			// 采样数 × 每样本数据位数 / 每字节位数(即8)
			var dataLength = this.recLength * (sampleBits / 8);
			var buffer = new ArrayBuffer(44 + dataLength);
			var view = new DataView(buffer);
			
			/* RIFF identifier */
			/* 资源交换文件标识符 */
			writeString(view, 0, 'RIFF');
			/* file length */
			/* 下个地址开始到文件尾总字节数,即文件大小-8 */
			view.setUint32(4, 36 + dataLength, true);
			/* RIFF type */
			/* WAV文件标志 */
			writeString(view, 8, 'WAVE');
			/* format chunk identifier */
			/* 波形格式标志 */
			writeString(view, 12, 'fmt ');
			/* format chunk length */
			/* 过滤字节,一般为 0x10 = 16 */
			view.setUint32(16, 16, true);
			/* sample format (raw) */
			/* 格式类别 (PCM形式采样数据) */
			view.setUint16(20, 1, true);
			/* channel count */
			/* 通道数 */
			view.setUint16(22, channelNumber, true);
			/* sample rate */
			/* 采样率,每秒样本数,表示每个通道的播放速度 */
			view.setUint32(24, sampleRate, true);
			/* byte rate (sample rate * block align) */
			/* 波形数据传输率 (每秒平均字节数) 通道数×每秒数据位数×每样本数据位/8 */
			view.setUint32(28, channelNumber * sampleRate * sampleBits / 8, true);
			/* block align (channel count * bytes per sample) */
			/* 快数据调整数 采样一次占用字节数 通道数×每样本的数据位数/8 */
			view.setUint16(32, channelNumber * sampleBits / 8, true);
			/* bits per sample */
			/* 每样本数据位数 */
			view.setUint16(34, sampleBits, true);
			/* data chunk identifier */
			/* 数据标识符 */
			writeString(view, 36, 'data');
			/* data chunk length */
			/* 采样数据总数,即数据总大小 */
			view.setUint32(40, dataLength, true);
			
			// 位移
			var offset = 44;
			for ( var i = 0; i < this.bufferL.length; i++) {
				for(var j = 0; j < this.bufferL[i].length; j++){
					// 左声道
					var s = Math.max(-1, Math.min(1, this.bufferL[i][j]));
					view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
					offset += 2;
					// 右声道
					if(channelNumber == 2){
						s = Math.max(-1, Math.min(1, this.bufferR[i][j]));
						view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
						offset += 2;
					}
				}
			}
			// mp2不存在则转换
			if(!that.mp2){
				self.postMessage({command : 'convert', wav : view.buffer, id : that.id});
			}
			this.blob = new Blob([ view ], {type : 'audio/wav'});
		}
		return this.blob;
	}
	// 转码完成
	this.converted = function(mp2){
		if(that.partMp2){
			that.wait[0].mp2 = mp2;
		}else{
			that.mp2 = mp2;
		}
	}
	// 开始录音
	this.currentCall = this.start;
	this.received = true;
	this.intervalFunction = function() {
		// 如果还没接收到反馈消息，则继续等待
		if(!that.received){
			return;
		}
		that.received = false;
		that.currentCall();
	}
	// 上传循环
	this.handle = setInterval(this.intervalFunction, 50);
}

var PCMSender = {
	buffer : [],
	start : function(testId, type, content, time, recordTime){
		var pcm = new PCMObject(testId, type, content, time, recordTime);
		this.buffer.push(pcm);
		self.postMessage({command : 'start', status : true});
		return pcm;
	},
	remove : function(){
//		this.buffer.shift();
	},
	length : function(){
		return this.buffer.length;
	},
	// 将录音数据添加到当前录音的最后
	record : function(bufferL, bufferR){
		this.buffer[this.buffer.length - 1].record(bufferL, bufferR);
	},
	stop : function(){
		if(this.buffer.length > 0){
			this.buffer[this.buffer.length - 1].stop();
		}
	},
	getWaveByTime : function(time){
		for ( var i = 0; i < this.buffer.length; i++) {
			if(this.buffer[i].time == time){
				self.postMessage({command : 'getWaveByTime', blob : this.buffer[i].getWave()});
				return;
			}
		}
		
		self.postMessage({command : 'getWaveByTime', blob : null});
	},
	getWaveByTimes : function(times){
		var blobs = new Array();
		for ( var i = 0; i < this.buffer.length; i++) {
			for (var j = 0; j < times.length; j++) {
				if(this.buffer[i].time == times[j]){
					blobs.push(this.buffer[i].getWave());
					break;
				}
			}
		}
		
		self.postMessage({command : 'getWaveByTimes', blob : blobs});
	},
	converted : function(id, mp2){
		for ( var i = 0; i < this.buffer.length; i++) {
			if(this.buffer[i].id == id){
				this.buffer[i].converted(mp2);
				break;
			}
		}
	}
};

self.onmessage = function(e) {
	switch (e.data.command) {
	case 'init':
		init(e.data);
		break;
	case 'start':
		PCMSender.start(e.data.testId, e.data.type, e.data.content, e.data.time, e.data.recordTime);
		break;
	case 'record':
		record(e.data.buffer);
		break;
	case 'stop':
		PCMSender.stop();
		break;
	case 'getWaveByTime':
		PCMSender.getWaveByTime(e.data.time);
		break;
	case 'getWaveByTimes':
		PCMSender.getWaveByTimes(e.data.times);
		break;
	case 'converted':
		PCMSender.converted(e.data.id, e.data.mp2); 
		break;
	}
};

function init(config) {
	sampleRate = config.sampleRate;
	channelNumber = config.channelNumber;
	sampleBits = config.sampleBits;
	TinSoConfig = config.TinSoConfig;
	importScripts(TinSoConfig.pub + '/js/json2.js');
	console.log('recorderWorder.js加载完成');
}

function record(inputBuffer) {
	if(channelNumber == 2){
		PCMSender.record(inputBuffer[0], inputBuffer[1]);
	}else{
		PCMSender.record(inputBuffer[0], new Float32Array(0));
	}
}

function ajax(url, data, callback, extra){
	var xhr;
	// IE7+, Firefox, Chrome, Opera, Safari
	if (!!XMLHttpRequest){
		xhr = new XMLHttpRequest();
	}
	// IE6, IE5
	else	{
		xhr = new ActiveXObject("Microsoft.XMLHTTP");
	}
	// 对ajax对象进行监听
	xhr.onreadystatechange = function(event){
		// 4表示解析完毕
		if(xhr.readyState == 4){
			// 200为正常返回，异常状态也要处理
//			if(xhr.status == 200){
				if(typeof callback == 'function'){
					callback(xhr.responseText);
				}
//			}
		}
	};
	xhr.withCredentials = true;
	xhr.open('POST', url, true);
	xhr.setRequestHeader('Request-Origin','web');
	if(typeof data == 'string'){
		xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
	}else{
		if(!!extra){
			xhr.setRequestHeader('Pcm-Data', extra);
		}
	}
	xhr.send(data);
}

function writeString(view, offset, string) {
	for ( var i = 0; i < string.length; i++) {
		view.setUint8(offset + i, string.charCodeAt(i));
	}
}